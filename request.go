// Copyright 2014 Matthew Baird, Andrew Mussey
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package saml

import (
	"encoding/base64"
	"encoding/xml"
	"errors"
	"net/url"
	"time"
)

type RequestedAuthnContext struct {
	XMLName              xml.Name
	SAMLP                string               `xml:"xmlns:samlp,attr"`
	Comparison           string               `xml:"Comparison,attr"`
	AuthnContextClassRef AuthnContextClassRef `xml:"AuthnContextClassRef"`
}

type NameIDPolicy struct {
	XMLName         xml.Name
	SPNameQualifier string `xml:"SPNameQualifier,attr,omitempty"`
	AllowCreate     bool   `xml:"AllowCreate,attr,omitempty"`
	Format          string `xml:"Format,attr,omitempty"`
}

func NewNameIDPolicy() *NameIDPolicy {
	return &NameIDPolicy{
		XMLName: xml.Name{
			Local: "samlp:NameIDPolicy",
		},
		AllowCreate: true,
		Format:      "urn:oasis:names:tc:SAML:2.0:nameid-format:transient",
	}
}

type IDPList struct {
}

type Scoping struct {
	ProxyCount  int      `xml:"ProxyCount,omitempty"`
	IDPList     IDPList  `xml:"IDPList,omitempty"`
	RequesterID []string `xml:"RequesterID"`
}

// An AuthnRequest is generated by SP(Service Provider) and send to IdP(Identity Provider)
// Refer: http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf  [Page 36, 48]
//
// Attributes and Sequences
//	Name							Type			Description
//	ID								ID				required; An identifier for the request.
//	Version							string			required; The version of the request.
//	IssueInstant					dateTime		required; The time instant of issue of the request.
//	Destination						anyURI			optional; A URI reference indicating the address to which this request has been sent.
//	Consent							anyURI			optional; Indicates whether or not consent has been obtained from a principal.
//	ForceAuthn						boolean			optional; Indicate IdP MUST authenticate directly or not.
//	IsPassive						boolean			optional; IdP can take control of the user interface or not.
//	ProtocolBinding					anyURI			optional; A URI reference that indetifies RESPONSE protocol binding.
//	AssertionConsumerServiceIndex	uint			optional; Indirectly identifies the location to which the <Response> message should be returned to the requester.
//	AssertionConsumerServiceURL		anyURI			optional; Specifies by value the location to which the <Response> message MUST be returned to the requester.
//	AttributeConsumingServiceIndex	uint			optional; Indirectly identifies the SAML attributes to be supplied by the identity provider
//	ProviderName					string			optional; Specifies the human-readable name of the requester for use by the presenter's user agent or the identity provider.
//	Issuer							Issuer			optional; Identifies the entity that generated the request message.
//	Signature						Signature		optional; An XML Signature that authenticates the requester and provides message integrity.
//	Subject							Subject			optional; Specifies the requested subject of the resulting assertion(s).
//	Conditions						Conditions		optional; Specifies the SAML conditions the requester expects to limit the validity and/or use of the resulting assertion(s).
//	Scoping							Scoping			optional; Specifies a set of identity providers trusted by the requester to authenticate the presenter
//
type AuthnRequest struct {
	XMLName                        xml.Name
	SAMLP                          string                `xml:"xmlns:samlp,attr"`
	SAML                           string                `xml:"xmlns:saml,attr"`
	SAMLSIG                        string                `xml:"xmlns:samlsig,attr,omitempty"`
	ID                             string                `xml:"ID,attr"`
	Version                        string                `xml:"Version,attr"`
	ProtocolBinding                string                `xml:"ProtocolBinding,attr"`
	AssertionConsumerServiceURL    string                `xml:"AssertionConsumerServiceURL,attr"`
	IssueInstant                   string                `xml:"IssueInstant,attr"`
	AssertionConsumerServiceIndex  int                   `xml:"AssertionConsumerServiceIndex,attr"`
	AttributeConsumingServiceIndex int                   `xml:"AttributeConsumingServiceIndex,attr"`
	Issuer                         Issuer                `xml:"Issuer"`
	NameIDPolicy                   NameIDPolicy          `xml:"NameIDPolicy,omitempty"`
	RequestedAuthnContext          RequestedAuthnContext `xml:"RequestedAuthnContext"`
	Signature                      *Signature            `xml:"Signature,omitempty"`
	Subject                        Subject               `xml:"Subject,omitempty"`
	Conditions                     Conditions            `xml:"Conditions,omitempty"`
	Scoping                        Scoping               `xml:"Scoping,omitempty"`
	originalString                 string
}

func ParseCompressedEncodedRequest(b64RequestXML string) (*AuthnRequest, error) {
	var authnRequest AuthnRequest
	compressedXML, err := base64.StdEncoding.DecodeString(b64RequestXML)
	if err != nil {
		return nil, err
	}
	bXML := decompress(compressedXML)

	err = xml.Unmarshal(bXML, &authnRequest)
	if err != nil {
		return nil, err
	}

	// There is a bug with XML namespaces in Go that's causing XML attributes with colons to not be roundtrip
	// marshal and unmarshaled so we'll keep the original string around for validation.
	authnRequest.originalString = string(bXML)
	return &authnRequest, nil

}

func ParseEncodedRequest(b64RequestXML string) (*AuthnRequest, error) {
	authnRequest := AuthnRequest{}
	bytesXML, err := base64.StdEncoding.DecodeString(b64RequestXML)
	if err != nil {
		return nil, err
	}
	err = xml.Unmarshal(bytesXML, &authnRequest)
	if err != nil {
		return nil, err
	}

	// There is a bug with XML namespaces in Go that's causing XML attributes with colons to not be roundtrip
	// marshal and unmarshaled so we'll keep the original string around for validation.
	authnRequest.originalString = string(bytesXML)
	return &authnRequest, nil
}

func (r *AuthnRequest) Validate(publicCertPath string) error {
	if r.Version != "2.0" {
		return errors.New("unsupported SAML Version")
	}

	if len(r.ID) == 0 {
		return errors.New("missing ID attribute on SAML Response")
	}

	// TODO more validation

	err := VerifyRequestSignature(r.originalString, publicCertPath)
	if err != nil {
		return err
	}

	return nil
}

// GetSignedAuthnRequest returns a singed XML document that represents a AuthnRequest SAML document
func (s *ServiceProviderSettings) GetAuthnRequest() *AuthnRequest {
	r := NewAuthnRequest()
	r.AssertionConsumerServiceURL = s.AssertionConsumerServiceURL
	r.Issuer.Url = s.IDPSSODescriptorURL
	r.Signature.KeyInfo.X509Data.X509Certificate.Cert = s.PublicCert()

	if !s.SPSignRequest {
		r.SAMLSIG = ""
		r.Signature = nil
	}

	return r
}

// GetAuthnRequestURL generate a URL for the AuthnRequest to the IdP with the SAMLRequst parameter encoded
func GetAuthnRequestURL(baseURL string, b64XML string, state string) (string, error) {
	u, err := url.Parse(baseURL)
	if err != nil {
		return "", err
	}

	q := u.Query()
	q.Add("SAMLRequest", b64XML)
	q.Add("RelayState", state)
	u.RawQuery = q.Encode()
	return u.String(), nil
}

const (
	_SAML_VERSION = "2.0"
	_SAMLP        = "urn:oasis:names:tc:SAML:2.0:protocol"
	_SAML         = "urn:oasis:names:tc:SAML:2.0:assertion"
	_SAMLSIG      = "http://www.w3.org/2000/09/xmldsig#"

	SAML_BINDING_HTTP_POST = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
)

func NewAuthnRequest() *AuthnRequest {
	id := ID()
	return &AuthnRequest{
		XMLName: xml.Name{
			Local: "samlp:AuthnRequest",
		},
		SAMLP:                       _SAMLP,
		SAML:                        _SAML,
		ID:                          id,
		ProtocolBinding:             SAML_BINDING_HTTP_POST,
		Version:                     _SAML_VERSION,
		AssertionConsumerServiceURL: "", // caller must populate ar.AppSettings.AssertionConsumerServiceURL,
		IssueInstant:                time.Now().UTC().Format(time.RFC3339Nano),
		RequestedAuthnContext: RequestedAuthnContext{
			XMLName: xml.Name{
				Local: "samlp:RequestedAuthnContext",
			},
			SAMLP:      "urn:oasis:names:tc:SAML:2.0:protocol",
			Comparison: "exact",
			AuthnContextClassRef: AuthnContextClassRef{
				XMLName: xml.Name{
					Local: "saml:AuthnContextClassRef",
				},
				SAML:      "urn:oasis:names:tc:SAML:2.0:assertion",
				Transport: "urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport",
			},
		},
		Signature: &Signature{
			XMLName: xml.Name{
				Local: "ds:Signature",
			},
			SAMLSIG: _SAMLSIG,
			SignedInfo: SignedInfo{
				XMLName: xml.Name{
					Local: "ds:SignedInfo",
				},
				CanonicalizationMethod: CanonicalizationMethod{
					XMLName: xml.Name{
						Local: "ds:CanonicalizationMethod",
					},
					Algorithm: "http://www.w3.org/2001/10/xml-exc-c14n#",
				},
				SignatureMethod: SignatureMethod{
					XMLName: xml.Name{
						Local: "ds:SignatureMethod",
					},
					Algorithm: "http://www.w3.org/2000/09/xmldsig#rsa-sha1",
				},
				SamlsigReference: SamlsigReference{
					XMLName: xml.Name{
						Local: "ds:Reference",
					},
					URI: "#" + id,
					Transforms: Transforms{
						XMLName: xml.Name{
							Local: "ds:Transforms",
						},
						Transform: []Transform{
							{
								XMLName: xml.Name{
									Local: "ds:Transform",
								},
								Algorithm: "http://www.w3.org/2000/09/xmldsig#enveloped-signature",
							},
							{
								XMLName: xml.Name{
									Local: "ds:Transform",
								},
								Algorithm: "http://www.w3.org/2001/10/xml-exc-c14n#",
							},
						},
					},
					DigestMethod: DigestMethod{
						XMLName: xml.Name{
							Local: "ds:DigestMethod",
						},
						Algorithm: "http://www.w3.org/2000/09/xmldsig#sha1",
					},
					DigestValue: DigestValue{
						XMLName: xml.Name{
							Local: "ds:DigestValue",
						},
					},
				},
			},
			SignatureValue: SignatureValue{
				XMLName: xml.Name{
					Local: "ds:SignatureValue",
				},
			},
			KeyInfo: KeyInfo{
				XMLName: xml.Name{
					Local: "ds:KeyInfo",
				},
				X509Data: X509Data{
					XMLName: xml.Name{
						Local: "ds:X509Data",
					},
					X509Certificate: X509Certificate{
						XMLName: xml.Name{
							Local: "ds:X509Certificate",
						},
						Cert: "", // caller must populate cert,
					},
				},
			},
		},
	}
}

func (r *AuthnRequest) String() (string, error) {
	b, err := xml.MarshalIndent(r, "", "    ")
	if err != nil {
		return "", err
	}

	return string(b), nil
}

func (r *AuthnRequest) SignedString(privateKeyPath string) (string, error) {
	s, err := r.String()
	if err != nil {
		return "", err
	}

	return SignRequest(s, privateKeyPath)
}

// GetAuthnRequestURL generate a URL for the AuthnRequest to the IdP with the SAMLRequst parameter encoded
func (r *AuthnRequest) EncodedSignedString(privateKeyPath string) (string, error) {
	signed, err := r.SignedString(privateKeyPath)
	if err != nil {
		return "", err
	}
	b64XML := base64.StdEncoding.EncodeToString([]byte(signed))
	return b64XML, nil
}

func (r *AuthnRequest) CompressedEncodedSignedString(privateKeyPath string) (string, error) {
	signed, err := r.SignedString(privateKeyPath)
	if err != nil {
		return "", err
	}
	compressed := compress([]byte(signed))
	b64XML := base64.StdEncoding.EncodeToString(compressed)
	return b64XML, nil
}

func (r *AuthnRequest) EncodedString() (string, error) {
	saml, err := r.String()
	if err != nil {
		return "", err
	}
	b64XML := base64.StdEncoding.EncodeToString([]byte(saml))
	return b64XML, nil
}

func (r *AuthnRequest) CompressedEncodedString() (string, error) {
	saml, err := r.String()
	if err != nil {
		return "", err
	}
	compressed := compress([]byte(saml))
	b64XML := base64.StdEncoding.EncodeToString(compressed)
	return b64XML, nil
}
